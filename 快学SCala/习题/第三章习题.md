[toc]
####1. 编写一段代码，将a设置为一个n个随机整数的数组，要求随机数介于0(包含)和n(不包含)之间。
```
val n = scala.util.Random.nextInt(10)
val arr = new Array[Int](n)

//OR

val n:Int=scala.util.Random.nextInt(10)
```

####2. 编写一个循环，将整数数组中相邻的元素置换，例如，Array(1,2,3,4,5)经过置换后变为Array(2,1,4,3,5).

####3. 重复前一个练习，不过这一次生成一个型的值交换过的数组。用for/yield.

####4. 给定一个整数数组，产出一个新的数组，包含原数组中的所有正值，以原有顺序排列，之后的元素是所有零或负值，以原有顺序排列。

####5. 如何计算Array[Double]的平均值。

####6. 如何重新组织Array[Int]的元素将它们以反序排列？对于ArrayBUffer[Int]你又会怎么做？


####7. 编写一段代码，产出数组中的所有值，去掉重复值。(提示：查看Scaladoc)

####8. 重新编写3.4结尾的示例。收集负值元素下标，反序，去掉最后一个下标，然后对每一个下标调用a.remove(i)。比较这样做的效率和3.4节中的另外两种方法的效率。

####9. 创建一个由java.util.TImeZone.getAvailableIDS返回的时区集合，判断条件是它们在美洲。去掉“America/”前缀并排序。

####10. 引入java.awt.datatransfer._并构建一个类型两个为SystemFlavorMap类型的对象：  val flavors = SystemFalvorMap.getDefaultFlavorMap().asInstanceOf(SystemFlavorMap),然后以DataFlavor.imageFlavor为参数调用getNativesForFlavor方法，以Scala缓冲保存返回值。